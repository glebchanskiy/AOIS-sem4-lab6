/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.glebchanskiy;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class SimpleHashMap<K, V> implements Map<K, V> {

    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;
    static final int MAXIMUM_CAPACITY = 1 << 10;

    int capacity;
    int size;
    final float loadFactor;
    Function<K, Integer> hashFunction;
    List<Node<K, V>>[] table;

    public SimpleHashMap() {
        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, Objects::hash);
    }

    public SimpleHashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR, Objects::hash);
    }

    public SimpleHashMap(Function<K, Integer> hashFunction) {
        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, hashFunction);
    }

    public SimpleHashMap(int initialCapacity, Function<K, Integer> hashFunction) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR, hashFunction);
    }

    public SimpleHashMap(int initialCapacity, float loadFactor, Function<K, Integer> hashFunction) {

        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                    initialCapacity);
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor <= 0)
            throw new IllegalArgumentException("Illegal load factor: " +
                    loadFactor);

        this.loadFactor = loadFactor;
        this.capacity = initialCapacity;
        this.hashFunction = hashFunction;

        prepareTable();

    }

    static class Node<K, V> {
        public Node(K key, V value, int hash) {
            this.key = key;
            this.value = value;
            this.hash = hash;
        }

        int hash;

        K key;
        V value;

        @Override
        public String toString() {
            return "Node{" +
                    "hash=" + hash +
                    ", key=" + key +
                    ", value=" + value +
                    '}';
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Node<?, ?> node = (Node<?, ?>) o;
            return hash == node.hash && Objects.equals(key, node.key);
        }

        @Override
        public int hashCode() {
            return Objects.hash(hash, key);
        }
    }

    void prepareTable() {
        this.table = new LinkedList[this.capacity];
        for (int i = 0; i < this.capacity; i++) {
            this.table[i] = new LinkedList<>();
        }
    }


    @Override
    public int size() {
        return size;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean containsKey(Object key) {
        int hash = hash(key);
        int index = hash % capacity;

        List<Node<K, V>> list = this.table[index];

        for (Node<K, V> value : list) {
            if (value.hash == hash && value.key.equals(key)) {
                return true;
            }
        }

        return false;
    }

    @Override
    public boolean containsValue(Object value) {
        return Stream.of(table)
                .flatMap(List::stream)
                .anyMatch(node -> Objects.equals(node.value, value));
    }

    @Override
    public V get(Object key) {
        int hash = hash(key);
        int index = hash % capacity;

        List<Node<K, V>> list = this.table[index];

        for (Node<K, V> value : list) {
            if (value.hash == hash && value.key.equals(key)) {
                return value.value;
            }
        }

        return null;
    }

    @Override
    public V put(K key, V value) {
        resize();
        return putVal(hash(key), key, value);
    }

    private V putVal(int hash, K key, V value) {
        int index = hash % capacity;

        Node<K, V> node = new Node<>(key, value, hash);

        this.table[index].remove(node);
        this.table[index].add(node);
        this.size++;
        return null;
    }

    @Override
    public V remove(Object key) {
        int hash = hash(key);
        int index = hash % capacity;

        List<Node<K, V>> list = this.table[index];

        if (list.removeIf(value -> value.hash == hash && value.key.equals(key)))
            size--;

        return this.table[index].size() - 1 >= 0 ? // previous value associated with key, or null if there was no mapping for key.
                this.table[index].get(this.table[index].size() - 1).value : null;
    }

    @Override
    public void putAll(Map<? extends K, ? extends V> m) {
        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
            this.put(e.getKey(), e.getValue());
        }
    }

    @Override
    public void clear() {
        Stream.of(this.table).forEach(List::clear);
        this.size = 0;
    }

    @Override
    public Set<K> keySet() {
        return Stream.of(this.table)
                .flatMap(List::stream)
                .distinct()
                .map(node -> node.key)
                .collect(Collectors.toSet());
    }

    @Override
    public Collection<V> values() {
        return Stream.of(this.table)
                .flatMap(List::stream)
                .distinct()
                .map(node -> node.value)
                .collect(Collectors.toSet());
    }

    @Override
    public Set<Entry<K, V>> entrySet() {
        return Stream.of(this.table)
                .flatMap(List::stream)
                .map(node -> new Entry<K, V>() {
                    private V value;
                    @Override
                    public K getKey() {
                        return node.key;
                    }
                    @Override
                    public V getValue() {
                        return node.value;
                    }
                    @Override
                    public V setValue(V value) {
                        V old = this.value;
                        this.value = value;
                        return old;
                    }
                }).collect(Collectors.toSet());
    }

    private boolean isNeedToResize() {
        return (float) this.size / this.capacity > this.loadFactor;
    }

    private void resize() {
        if (isNeedToResize()) {
            System.out.println("RESIZING");
            this.capacity *= 2;
            this.size = 0;

            List<Node<K, V>>[] oldTable = this.table.clone();
            prepareTable();

            for (List<Node<K, V>> bucket : oldTable) {
                for (Node<K, V> node : bucket) {
                    put(node.key, node.value);
                }
            }
        }
    }

    public int hash(Object key) {
        return Math.abs(this.hashFunction.apply((K) key));
    }

    @Override
    public String toString() {
        StringBuilder output = new StringBuilder();
        for (List<Node<K, V>> innerList : this.table) {
            if (!innerList.isEmpty()) {
                Node<K, V> start = innerList.get(0);
                output.append("[").append(start.key).append("]");
                for (Node<K, V> node : innerList)
                    if (node.equals(start))
                        output.append(" : ").append(node);
                    else
                        output.append(" --> ").append(node);
                output.append('\n');
            } else {
                output.append("[null]").append('\n');
            }
        }
        return "SimpleHashMap{" +
                "\n\tcapacity=" + capacity +
                "\n\tcurrent load=" + (float) size / capacity +
                "\n\tsize=" + size +
                "\n\tloadFactor=" + loadFactor +
                "\n\tEntry=\n" + output +
                "}";
    }
}
